"use strict";(self.webpackChunkblog_vuepress_next=self.webpackChunkblog_vuepress_next||[]).push([[5493],{1228:(n,s,a)=>{a.r(s),a.d(s,{data:()=>e});const e={key:"v-c163cbde",path:"/views/front-end/qiankun-CSS-sandbox-isolation-solution.html",title:"qiankun的css样式污染解决方案",lang:"en-US",frontmatter:{title:"qiankun的css样式污染解决方案",categories:["Micro-front-end"],tags:["Micro-front-end"],keywords:"Micro-front-end",description:"qiankun的css样式污染解决方案",cover:"https://cdn.jsdelivr.net/gh/LeeDebug/PicGo/img/20201220000516.png",date:"2020-12-19T23:57:26.000Z"},excerpt:"",headers:[],git:{createdTime:163785445e4,updatedTime:163785445e4,contributors:[{name:"licc",email:"961150665@qq.com",commits:1}]}}},8976:(n,s,a)=>{a.r(s),a.d(s,{default:()=>o});const e=(0,a(6252).uE)('<blockquote><p>在使用qiankun框架做微前端开发的过程中，遇到了诸多难题，比如路由重定向、变量名及事件名冲突、挂载注销机制及生命周期、keep-alive等，目前遇到的比较难解决的问题可能就是css样式污染问题了。这次抽出了几天时间研究了一下，遂总结此文</p></blockquote><h1 id="问题概述" tabindex="-1"><a class="header-anchor" href="#问题概述" aria-hidden="true">#</a> 问题概述</h1><p>在qiankun加载子应用后，主子应用的样式之间会产生污染，常见的css样式污染有以下几种情况：</p><ul><li>无论是否进行样式隔离：主应用的样式污染了子应用（原因：主应用的样式添加了 <code>!important</code> 属性或 <code>&gt;&gt;&gt;</code> 穿透属性）</li><li>未进行样式隔离：子应用的样式污染了主应用（原因：样式重名，后加载的优先级高）</li><li>处理过样式隔离：子应用打开的弹窗、抽屉、popover等这种需要插入到主应用body的dom元素，样式丢失或应用了主项目的样式（原因：开启沙箱时，子应用的样式作用域只在子应用内，但如描述，子应用的dom被插入到了主应用的body中，遂出现了此种情况）</li></ul><h1 id="qiankun自带的css沙箱" tabindex="-1"><a class="header-anchor" href="#qiankun自带的css沙箱" aria-hidden="true">#</a> qiankun自带的css沙箱</h1><p>个人理解，qiankun加载子项目css样式机制大体为：挂载子应用时将子应用的css样式以style标签的形式插入并做快照，卸载子应用时再将快照内的style样式删除。所以在加载子应用期间，若未开启css沙箱隔离，后加载的这些样式，可能会对整个系统的样式产生影响，对此，qiankun提供了两种css沙箱功能，可以将子应用的样式包裹在沙箱容器内部，以此来达到样式隔离的目的。大体代码如下所示：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">this</span><span class="token punctuation">.</span>microApp <span class="token operator">=</span> <span class="token function">loadMicroApp</span><span class="token punctuation">(</span>\n  <span class="token punctuation">{</span> apps infos <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">{</span>\n    sandbox<span class="token operator">:</span> <span class="token punctuation">{</span>\n      strictStyleIsolation<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token comment">// 严格沙箱</span>\n      experimentalStyleIsolation<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token comment">// 实验性沙箱</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><ol><li>严格沙箱</li></ol><p>在加载子应用时，添加<code>strictStyleIsolation: true</code>属性，实现形式为将整个子应用放到<code>Shadow DOM</code>内进行嵌入，完全隔离了主子应用</p><p>缺点：</p><ul><li>子应用的弹窗、抽屉、popover因找不到主应用的body会丢失，或跑到整个屏幕外（具体原因作者并未详细研究）</li><li>主应用不方便去修改子应用的样式</li></ul><ol start="2"><li>实验性沙箱</li></ol><p>在加载子应用时，添加<code>experimentalStyleIsolation: true</code>属性，实现形式类似于vue中style标签中的scoped属性，qiankun会自动为子应用所有的样式增加后缀标签，如：<code>div[data-qiankun-microName]</code></p><p>缺点：</p><ul><li>子应用的弹窗、抽屉、popover因插入到了主应用的body，所以导致样式丢失或应用了主应用了样式</li></ul><h1 id="最终解决方案" tabindex="-1"><a class="header-anchor" href="#最终解决方案" aria-hidden="true">#</a> 最终解决方案</h1><p>说了这么多qiankun自带的css沙箱隔离，但都有各自的缺点，并且对于系统的实现上，影响范围还比较严重，代码的修改范围也比较大。作者的项目中，主子应用都是vue项目，并且都用了element家的样式且都各自魔改过，遂果断<span style="color:red;font-weight:900;">不开启css沙箱，给各自的项目class全局加上一个各自的命名空间</span>，可以自己的项目名，比如：<code>myVue body</code>、<code>myVue el-form-info__label</code>、<code>myVue customClass</code>等。</p><h1 id="代码实现" tabindex="-1"><a class="header-anchor" href="#代码实现" aria-hidden="true">#</a> 代码实现</h1><ol><li>添加依赖</li></ol><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>→ <span class="token function">npm</span> i postcss-plugin-namespace -D\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ol start="2"><li>配置postcss</li></ol><p>在项目根目录创建<code>postcss.config.js</code>文件，并复制以下内容：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// console.log(&#39;=&gt; =&gt; =&gt; postcss.config.js start =&gt; =&gt; =&gt;&#39;)</span>\nmodule<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">ctx</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">{</span>\n    plugins<span class="token operator">:</span> <span class="token punctuation">[</span>\n      <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;postcss-plugin-namespace&#39;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">&#39;#lee_project&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n        ignore<span class="token operator">:</span> <span class="token punctuation">[</span>\n          <span class="token string">&#39;html&#39;</span><span class="token punctuation">,</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">body</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span> <span class="token string">&#39;span&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;el-form-item&#39;</span>\n        <span class="token punctuation">]</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n    <span class="token punctuation">]</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// console.log(&#39;=&gt; =&gt; =&gt; postcss.config.js end =&gt; =&gt; =&gt;&#39;)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>该插件会将全局所有class前加上统一前缀，并过滤掉ignore内的标签；ignore内可以写字符串，可以写正则表达式。但每次编译前都会运行，所以可能会增加编译时间，所以日常开发环境下可以将此文件名随便改成别的，上线前记得改回来调试一下（如果直接隐藏掉代码的话，只要有<code>postcss.config.js</code>这个文件webpack会自动帮你执行，并且会提示你的postcss啥也没干，也相当于每次都走了这个脚本）。</p><p>注意：如果用<code>/body/</code>这样的正则，会将所有带body的class都过滤掉，比如<code>el-drawer__body</code>、<code>el-dialog__body</code>等。</p><h1 id="祝君无bug" tabindex="-1"><a class="header-anchor" href="#祝君无bug" aria-hidden="true">#</a> 祝君无Bug~</h1>',26),p={},o=(0,a(3744).Z)(p,[["render",function(n,s){return e}]])}}]);